PARSER_BEGIN(Parser)
package minjavac.manualParser;

import java.io.*;
import java.util.*;
import java.lang.reflect.Field;
import minjavac.manualParser.grammar.*;

public class Parser {
  public static void main(String[] args) throws Exception {
    Parser p = new Parser(new StringReader(minJavaGrammar));
    p.parse();
  }

  private static String minJavaGrammar =
    "<E>  ::= <T> <Ep>;" +
    "<Ep> ::= <ADD> <T> <Ep> | #;" +
    "<T>  ::= <F> <Tp>;" +
    "<Tp> ::= <MULT> <F> <Tp> | #;" +
    "<F>  ::= <LPARENS> <E> <RPARENS> | <NUM> | <ID>;"
  ;

  private List<Rule> grammar;
  private Set<String> nonTerminals;
  private Map<String,Integer> terminalId;
  private Map<String,Set<String>> first, follow;
  private static final String lambda = "#";

  public void parse() throws Exception {
    processGrammar();
    mountFirst();

    for (String var : nonTerminals())
      System.out.println("first(" + var + ") = " + first.get(var));

    mountFollow();

    for (String var : nonTerminals())
      System.out.println("follow(" + var + ") = " + follow.get(var));

    try {
      checkLL1();
    } catch (Exception e) {
      System.out.println(e.getMessage());
    }
  }

  private void processGrammar() throws Exception {
    grammar = new GrammarParser
      ( new StringReader(minJavaGrammar) ).parse();

    nonTerminals = new HashSet<String>();
    terminalId = new HashMap<String,Integer>();

    for (Field f : ParserConstants.class.getDeclaredFields()) {
      String name = f.getName();
      if (name.equals("tokenImage") || name.equals("DEFAULT")) continue;

      terminalId.put(name, f.getInt(this));
    }

    for (Rule r : grammar) {
      String lhs = r.getLhs();

      if (terminalId.containsKey(lhs))
        throw new Exception("Terminal appears on left side of rule: " + r);

      nonTerminals.add(lhs);
    }

    for (Rule r : grammar) for (String rhs : r.getRhs())
      if (!(terminalId.containsKey(rhs) || nonTerminals.contains(rhs) ||
            rhs.equals(lambda)))
        throw new Exception("Unknown label: " + rhs + ", on rule: " + r);
  }

  private void mountFirst() {
    first = new HashMap<String,Set<String>>();

    for (String terminal : terminals()) {
      Set<String> conj = new HashSet<String>();
      conj.add(terminal);
      first.put(terminal, conj);
    }

    Set<String> conj = new HashSet<String>();
    conj.add(lambda);
    first.put(lambda, conj);

    for (String var : nonTerminals()) {
      first.put(var, new HashSet<String>());
    }

    boolean changed = true;

    while (changed) {
      changed = false;

      for (Rule r : grammar) {
        String a = r.getLhs();
        Set<String> old = new HashSet(first.get(a));

        List<String> rhs = r.getRhs();

        Set<String> firstA = first.get(a);

        int i = 0;
        firstA.addAll(filterLambda(first.get(rhs.get(i))));

        while (i < rhs.size() - 1 && first.get(rhs.get(i)).contains(lambda))
          firstA.addAll(filterLambda(first.get(rhs.get(++i))));

        if (i == rhs.size()-1 && first.get(rhs.get(i)).contains(lambda))
          firstA.add(lambda);

        if (!changed && !old.equals(firstA))
          changed = true;
      }
    }
  }

  private void mountFollow() {
    follow = new HashMap<String,Set<String>>();

    for (String t : terminals())
      follow.put(t, new HashSet<String>());

    for (String v : nonTerminals())
      follow.put(v, new HashSet<String>());

    follow.put(lambda, new HashSet<String>());
    follow.get(grammar.get(0).getLhs()).add("EOF");

    boolean changed = true;

    while (changed) {
      changed = false;

      for (Rule r : grammar) {
        String a = r.getLhs();
        List<String> rhs = r.getRhs();

        Set<String> followA = follow.get(a);
        Set<String> followBk = follow.get(rhs.get(rhs.size()-1));
        Set<String> oldFollowBk = new HashSet<String>(followBk);
        Set<String> trailer = new HashSet<String>();

        followBk.addAll(followA);
        trailer.addAll(followA);

        if (!changed && !oldFollowBk.equals(followBk))
          changed = true;

        for (int i = rhs.size()-1; i >= 1; --i) {
          Set<String> firstBi = first.get(rhs.get(i));
          Set<String> followBi1 = follow.get(rhs.get(i-1));
          Set<String> oldFollowBi1 = new HashSet<String>(followBi1);

          followBi1.addAll(filterLambda(firstBi));

          if (firstBi.contains(lambda))
            followBi1.addAll(trailer);
          else
            trailer = firstBi;

          if (!changed && !oldFollowBi1.equals(followBi1))
            changed = true;
        }
      }
    }
  }

  private void checkLL1() throws Exception {
    int sz = grammar.size();
    for (int i = 0; i < sz; ++i)
      for (int j = 0; j < sz; ++j) {
        if (i == j) continue;

        Rule r1 = grammar.get(i);
        Rule r2 = grammar.get(j);

        if (!(r1.getLhs().equals(r2.getLhs()))) continue;

        String a = r1.getLhs();

        List<String> alpha = r1.getRhs(), beta = r2.getRhs();

        Set<String> followA = follow.get(a);
        Set<String> firstAlpha = sentenceFirst(alpha);
        Set<String> firstBeta = sentenceFirst(beta);

        if (!intersection(firstAlpha, firstBeta).isEmpty())
          throw new Exception(
            "LL(1) conflict: first sets intersection on rules " +
            r1 + " and " + r2
          );

        if (firstBeta.contains(lambda) &&
            !intersection(firstAlpha, followA).isEmpty())
          throw new Exception(
            "LL(1) conflict: rule " + r2 + " can be lambda and " +
            " rule " + r1 + " conflicts with follow of " + r1.getLhs()
          );
      }
  }

  private Set<String> terminals() {
    return terminalId.keySet();
  }

  private Set<String> nonTerminals() {
    return nonTerminals;
  }

  private Set<String> filterLambda(Set<String> s) {
    if (s.contains(lambda)) {
      Set<String> ns = new HashSet<String>(s);
      ns.remove(lambda);
      return ns;
    }
    else {
      return s;
    }
  }

  private Set<String> sentenceFirst(List<String> l) {
    Set<String> sfirst = new HashSet<String>();

    int i = 0;
    sfirst.addAll(filterLambda(first.get(l.get(i))));

    while (i < l.size()-1 && first.get(l.get(i)).contains(lambda))
      sfirst.addAll(filterLambda(first.get(l.get(++i))));

    if (i == l.size()-1 && first.get(l.get(i)).contains(lambda))
      sfirst.add(lambda);

    return sfirst;
  }

  private <T> Set<T> intersection(Set<T> a, Set<T> b) {
    Set<T> s = new HashSet<T>(a);
    s.retainAll(b);
    return s;
  }

  private void match(int tok) throws ParseException {
    getNextToken();

    if (token.kind != tok)
      throw new ParseException("Parse error: "
           + "unexpected " + token.image +
             ", expected " + ParserConstants.tokenImage[tok]);
  }

  private boolean lookahead(int tok) throws ParseException {
    return getToken(1).kind == tok;
  }
}
PARSER_END(Parser)


SKIP : /* White space */
{
  " " | "\t" | "\n" | "\r" | "\f"
}


SPECIAL_TOKEN : /* Comments */
{
  < LINE_COMMENT      :
    "//" (~["\n","\r"])* ("\n" | "\r" (~[]))?
  > |

  < FORMAL_COMMENT    :
    "/**" (~["/"] ( ~["*"] | "*" ~["/"] )* ("*")? )? "*/"
  > |

  < MULTILINE_COMMENT :
    "/*" (~["*"] | "*" ~["/"])* ("*")? "*/"
  >
}


TOKEN : /* Keywords */
{
   < INT       : "int" >
 | < VOID      : "void" >
 | < STRING    : "String" >
 | < BOOLEAN   : "boolean" >

 | < NULL      : "null" >
 | < THIS      : "this" >
 | < TRUE      : "true" >
 | < FALSE     : "false" >

 | < MAIN      : "main" >
 | < LENGTH    : "length" >
 | < PRINT     : "System.out.println" >

 | < IF        : "if" >
 | < NEW       : "new" >
 | < ELSE      : "else" >
 | < CLASS     : "class" >
 | < WHILE     : "while" >
 | < PUBLIC    : "public" >
 | < RETURN    : "return" >
 | < STATIC    : "static" >
 | < EXTENDS   : "extends" >
 | < INTERFACE : "interface" >
}


TOKEN : /* Operators */
{
   < ADD  : "+" >
 | < SUB  : "-" >
 | < MULT : "*" >

 | < AND  : "&&" >
 | < NOT  : "!" >
 | < LESS : "<" >

 | < ASSIGN : "=" >
}


TOKEN : /* Separators */
{
   < LPARENS  : "(" >
 | < RPARENS  : ")" >
 | < RBRACKET : "[" >
 | < LBRACKET : "]" >
 | < LBRACE   : "{" >
 | < RBRACE   : "}" >

 | < COMMA : "," >
 | < DOT   : "." >
 | < SEMI  : ";" >
}


TOKEN : /* Numbers */
{
  < NUM : "0" | ["1"-"9"](["0"-"9"])* >
}


TOKEN : /* Identifiers */
{
    < ID : <LETTER> (<LETTER> | ["0"-"9"])* >

  | < #LETTER : "$" | "_" | ["a"-"z","A"-"Z"] >
}
