/* Generated By:JavaCC: Do not edit this line. Parser.java */
package minjavac.manualParser;

import java.io.*;
import java.util.*;
import java.lang.reflect.Field;
import minjavac.manualParser.grammar.*;

public class Parser implements ParserConstants {
  public static void main(String[] args) throws Exception {
    Parser p = new Parser(new StringReader(minJavaGrammar));
    p.parse();
  }

  private static String minJavaGrammar =
    "<E>  ::= <T> <Ep>;" +
    "<Ep> ::= <ADD> <T> <Ep> | #;" +
    "<T>  ::= <F> <Tp>;" +
    "<Tp> ::= <MULT> <F> <Tp> | #;" +
    "<F>  ::= <LPARENS> <E> <RPARENS> | <NUM> | <ID>;"
  ;

  private List<Rule> grammar;
  private Set<String> nonTerminals;
  private Map<String,Integer> terminalId;
  private Map<String,Set<String>> first, follow;
  private static final String lambda = "#";

  public void parse() throws Exception {
    processGrammar();
    mountFirst();

    for (String var : nonTerminals())
      System.out.println("first(" + var + ") = " + first.get(var));

    mountFollow();

    for (String var : nonTerminals())
      System.out.println("follow(" + var + ") = " + follow.get(var));

    try {
      checkLL1();
    } catch (Exception e) {
      System.out.println(e.getMessage());
    }
  }

  private void processGrammar() throws Exception {
    grammar = new GrammarParser
      ( new StringReader(minJavaGrammar) ).parse();

    nonTerminals = new HashSet<String>();
    terminalId = new HashMap<String,Integer>();

    for (Field f : ParserConstants.class.getDeclaredFields()) {
      String name = f.getName();
      if (name.equals("tokenImage") || name.equals("DEFAULT")) continue;

      terminalId.put(name, f.getInt(this));
    }

    for (Rule r : grammar) {
      String lhs = r.getLhs();

      if (terminalId.containsKey(lhs))
        throw new Exception("Terminal appears on left side of rule: " + r);

      nonTerminals.add(lhs);
    }

    for (Rule r : grammar) for (String rhs : r.getRhs())
      if (!(terminalId.containsKey(rhs) || nonTerminals.contains(rhs) ||
            rhs.equals(lambda)))
        throw new Exception("Unknown label: " + rhs + ", on rule: " + r);
  }

  private void mountFirst() {
    first = new HashMap<String,Set<String>>();

    for (String terminal : terminals()) {
      Set<String> conj = new HashSet<String>();
      conj.add(terminal);
      first.put(terminal, conj);
    }

    Set<String> conj = new HashSet<String>();
    conj.add(lambda);
    first.put(lambda, conj);

    for (String var : nonTerminals()) {
      first.put(var, new HashSet<String>());
    }

    boolean changed = true;

    while (changed) {
      changed = false;

      for (Rule r : grammar) {
        String a = r.getLhs();
        Set<String> old = new HashSet(first.get(a));

        List<String> rhs = r.getRhs();

        Set<String> firstA = first.get(a);

        int i = 0;
        firstA.addAll(filterLambda(first.get(rhs.get(i))));

        while (i < rhs.size() - 1 && first.get(rhs.get(i)).contains(lambda))
          firstA.addAll(filterLambda(first.get(rhs.get(++i))));

        if (i == rhs.size()-1 && first.get(rhs.get(i)).contains(lambda))
          firstA.add(lambda);

        if (!changed && !old.equals(firstA))
          changed = true;
      }
    }
  }

  private void mountFollow() {
    follow = new HashMap<String,Set<String>>();

    for (String t : terminals())
      follow.put(t, new HashSet<String>());

    for (String v : nonTerminals())
      follow.put(v, new HashSet<String>());

    follow.put(lambda, new HashSet<String>());
    follow.get(grammar.get(0).getLhs()).add("EOF");

    boolean changed = true;

    while (changed) {
      changed = false;

      for (Rule r : grammar) {
        String a = r.getLhs();
        List<String> rhs = r.getRhs();

        Set<String> followA = follow.get(a);
        Set<String> followBk = follow.get(rhs.get(rhs.size()-1));
        Set<String> oldFollowBk = new HashSet<String>(followBk);
        Set<String> trailer = new HashSet<String>();

        followBk.addAll(followA);
        trailer.addAll(followA);

        if (!changed && !oldFollowBk.equals(followBk))
          changed = true;

        for (int i = rhs.size()-1; i >= 1; --i) {
          Set<String> firstBi = first.get(rhs.get(i));
          Set<String> followBi1 = follow.get(rhs.get(i-1));
          Set<String> oldFollowBi1 = new HashSet<String>(followBi1);

          followBi1.addAll(filterLambda(firstBi));

          if (firstBi.contains(lambda))
            followBi1.addAll(trailer);
          else
            trailer = firstBi;

          if (!changed && !oldFollowBi1.equals(followBi1))
            changed = true;
        }
      }
    }
  }

  private void checkLL1() throws Exception {
    int sz = grammar.size();
    for (int i = 0; i < sz; ++i)
      for (int j = 0; j < sz; ++j) {
        if (i == j) continue;

        Rule r1 = grammar.get(i);
        Rule r2 = grammar.get(j);

        if (!(r1.getLhs().equals(r2.getLhs()))) continue;

        String a = r1.getLhs();

        List<String> alpha = r1.getRhs(), beta = r2.getRhs();

        Set<String> followA = follow.get(a);
        Set<String> firstAlpha = sentenceFirst(alpha);
        Set<String> firstBeta = sentenceFirst(beta);

        if (!intersection(firstAlpha, firstBeta).isEmpty())
          throw new Exception(
            "LL(1) conflict: first sets intersection on rules " +
            r1 + " and " + r2
          );

        if (firstBeta.contains(lambda) &&
            !intersection(firstAlpha, followA).isEmpty())
          throw new Exception(
            "LL(1) conflict: rule " + r2 + " can be lambda and " +
            " rule " + r1 + " conflicts with follow of " + r1.getLhs()
          );
      }
  }

  private Set<String> terminals() {
    return terminalId.keySet();
  }

  private Set<String> nonTerminals() {
    return nonTerminals;
  }

  private Set<String> filterLambda(Set<String> s) {
    if (s.contains(lambda)) {
      Set<String> ns = new HashSet<String>(s);
      ns.remove(lambda);
      return ns;
    }
    else {
      return s;
    }
  }

  private Set<String> sentenceFirst(List<String> l) {
    Set<String> sfirst = new HashSet<String>();

    int i = 0;
    sfirst.addAll(filterLambda(first.get(l.get(i))));

    while (i < l.size()-1 && first.get(l.get(i)).contains(lambda))
      sfirst.addAll(filterLambda(first.get(l.get(++i))));

    if (i == l.size()-1 && first.get(l.get(i)).contains(lambda))
      sfirst.add(lambda);

    return sfirst;
  }

  private <T> Set<T> intersection(Set<T> a, Set<T> b) {
    Set<T> s = new HashSet<T>(a);
    s.retainAll(b);
    return s;
  }

  private void match(int tok) throws ParseException {
    getNextToken();

    if (token.kind != tok)
      throw new ParseException("Parse error: "
           + "unexpected " + token.image +
             ", expected " + ParserConstants.tokenImage[tok]);
  }

  private boolean lookahead(int tok) throws ParseException {
    return getToken(1).kind == tok;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public ParserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[0];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {};
   }

  /** Constructor with InputStream. */
  public Parser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Parser(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Parser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Parser(ParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[49];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 0; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 49; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
