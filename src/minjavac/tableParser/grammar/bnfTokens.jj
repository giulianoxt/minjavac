PARSER_BEGIN(GrammarParser)
package minjavac.manualParser.grammar;

import java.util.LinkedList;
import java.util.List;

public class GrammarParser {
  private boolean firstRule;
  private String firstSymbol;
  private List<Rule> grammar;

  public List<Rule> parse() throws ParseException {
    firstRule = true;
    grammar = new LinkedList<Rule>();

    while (true) {
      rule();
      match(EOR);
      if (lookahead(EOF)) break;
    }

    match(EOF);

    return grammar;
  }

  public void rule() throws ParseException {
    match(ID);
    String lhs = token.image;

    if (firstRule) {
      firstRule = false;
      firstSymbol = removeBrackets(lhs);
    }

    match(ASSIGN);
    rightHandSide(lhs);
  }

  public void rightHandSide(String lhs) throws ParseException {
    String nlhs = lhs;

    while (true) {
      if (lookahead(LAMBDA)) {
        match(LAMBDA);
        addRule(new Rule(lhs));
      }
      else {
        List<String> rhs = new LinkedList<String>();

        while (true) {
          if (lookahead(ID)) {
            match(ID);
            rhs.add(token.image);
          }
          else if (lookahead(LPARENS)) {
            nlhs = addPrefix(nlhs);

            match(LPARENS);
            rightHandSide(nlhs);
            match(RPARENS);

            if (lookahead(STAR)) {
              match(STAR);

              boolean has_lambda = false;

              for (Rule r : getMatchingRules(nlhs))
                if (r.isLambda())
                  has_lambda = true;
                else
                  r.getRhs().add(removeBrackets(nlhs));

              if (!has_lambda)
                addRule(new Rule(nlhs, lambdaRhs()));
            }

            rhs.add(nlhs);
          }
          else if (lookahead(LBRACKET)) {
            nlhs = addPrefix(nlhs);

            match(LBRACKET);
            rightHandSide(nlhs);
            match(RBRACKET);

            addRule(new Rule(nlhs, lambdaRhs()));
            rhs.add(nlhs);
          }
          else {
            break;
          }
        }

        addRule(new Rule(lhs, rhs));
      }

      if (lookahead(CHOICE))
        match(CHOICE);
      else
        break;
    }
  }

  public String getFirstSymbol() {
    return firstSymbol;
  }

  private String addPrefix(String s) {
    return "<" + "@" + s.substring(1);
  }

  private void addRule(Rule r) {
    if (grammar.isEmpty()) {
      grammar.add(r);
      return;
    }

    String lhs = r.getLhs();
    int i = grammar.size()-1;

    while (i >= 0) {
      Rule _r = grammar.get(i--);
      if (!_r.getLhs().endsWith(lhs)) break;
    }

    grammar.add(i+1, r);
  }

  private String removeBrackets(String s) {
    if (s.startsWith("<"))
      return s.substring(1, s.length()-1);
    else
      return s;
  }

  private List<String> lambdaRhs() {
    return new LinkedList<String>();
  }

  private List<Rule> getMatchingRules(String lhs) {
    lhs = removeBrackets(lhs);
    List<Rule> l = new LinkedList<Rule>();

    for (Rule r : grammar)
      if (r.getLhs().equals(lhs))
        l.add(r);

    return l;
  }

  private void match(int tok) throws ParseException {
    getNextToken();

    if (token.kind != tok)
      throw new ParseException("Parse error: "
           + "unexpected " + token.image +
             ", expected " + GrammarParserConstants.tokenImage[tok]);
  }

  private boolean lookahead(int tok) throws ParseException {
    return getToken(1).kind == tok;
  }
}
PARSER_END(GrammarParser)


SKIP : /* White space */
{
  " " | "\t" | "\n" | "\r" | "\f"
}


SPECIAL_TOKEN : /* Comments */
{
  < LINE_COMMENT      :
    "//" (~["\n","\r"])* ("\n" | "\r" (~[]))?
  > |

  < FORMAL_COMMENT    :
    "/**" (~["/"] ( ~["*"] | "*" ~["/"] )* ("*")? )? "*/"
  > |

  < MULTILINE_COMMENT :
    "/*" (~["*"] | "*" ~["/"])* ("*")? "*/"
  >
}


TOKEN : /* Keywords */
{
   < ASSIGN   : "::=" >
 | < CHOICE   : "|" >
 | < EOR      : ";" >
 | < LPARENS  : "(" >
 | < RPARENS  : ")" >
 | < LBRACKET : "[" >
 | < RBRACKET : "]" >
 | < STAR     : "*" >
 | < LAMBDA   : "#" >
 | < ID       : "<" (["a"-"z","A"-"Z"])+ ">" >
}
